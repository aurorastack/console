<template>
    <div>
        <p-page-title :title="pageTitle"
                      use-total-count use-selected-count
                      :total-count="typeOptionState.totalCount"
                      :selected-count="tableState.selectedItems.length"
                      :child="isCloudService"
                      @goBack="$router.go(-1)"
        />
        <slot name="period-filter" />
        <p-horizontal-layout :min-height="minHeight" :height="tableState.tableHeight" @drag-end="handleTableHeightChange">
            <template #container="{ height }">
                <p-dynamic-layout v-if="tableState.schema"
                                  type="query-search-table"
                                  :options="tableState.schema.options"
                                  :data="tableState.items"
                                  :fetch-options="fetchOptionState"
                                  :type-options="typeOptionState"
                                  :style="{height: `${height}px`}"
                                  :field-handler="fieldHandler"
                                  @fetch="fetchTableData"
                                  @select="handleSelect"
                                  @export="exportServerData"
                                  @click-settings="handleClickSettings"
                >
                    <template #toolbox-left>
                        <div class="flex">
                            <p-button style-type="primary-dark" font-weigth="bold" :outline="true"
                                      :disabled="!tableState.consoleLink || tableState.selectedItems.length > 1"
                                      @click="handleClickConnectToConsole"
                            >
                                {{ $t('INVENTORY.SERVER.MAIN.CONSOLE') }}
                            </p-button>
                        </div>
                    </template>
                    <template #toolbox-bottom>
                        <slot name="usage-overview" :filters="tableState.searchFilters" />
                    </template>
                </p-dynamic-layout>
            </template>
        </p-horizontal-layout>
        <p-tab v-if="tableState.selectedItems.length === 1"
               :tabs="singleItemTabState.tabs"
               :active-tab.sync="singleItemTabState.activeTab"
               :class="singleItemTabState.activeTab"
        >
            <template #details>
                <server-details :server-id="tableState.selectedServerIds[0]" />
            </template>
            <template #tag>
                <tags-panel :resource-id="tableState.selectedServerIds[0]"
                            resource-type="inventory.Server"
                            resource-key="server_id"
                />
            </template>
            <template #member>
                <server-member :server-project-id="tableState.selectedItems[0].project_id" />
            </template>
            <template #history>
                <server-history :server-id="tableState.selectedServerIds[0]" />
            </template>
            <template #monitoring>
                <monitoring :resource-type="monitoringState.resourceType"
                            :resources="monitoringState.resources"
                />
            </template>
        </p-tab>
        <p-tab v-else-if="typeOptionState.selectIndex.length > 1"
               :tabs="multiItemTabState.tabs"
               :active-tab.sync="multiItemTabState.activeTab"
               :class="multiItemTabState.activeTab"
        >
            <template #data>
                <p-dynamic-layout v-if="tableState.multiSchema"
                                  type="simple-table"
                                  :options="tableState.multiSchema.options"
                                  :type-options="{ colCopy: true, timezone: typeOptionState.timezone }"
                                  :data="tableState.selectedItems"
                                  :field-handler="fieldHandler"
                                  class="selected-data-tab"
                />
            </template>
            <template #monitoring>
                <monitoring :resource-type="monitoringState.resourceType"
                            :resources="monitoringState.resources"
                />
            </template>
        </p-tab>
        <div v-else class="empty-space">
            <p-empty>{{ $t('INVENTORY.SERVER.MAIN.NO_SELECTED_SERVER') }}</p-empty>
        </div>

        <p-table-check-modal v-if="!!checkTableModalState.visible"
                             :visible.sync="checkTableModalState.visible"
                             :header-title="checkTableModalState.title"
                             :sub-title="checkTableModalState.subTitle"
                             :theme-color="checkTableModalState.themeColor"
                             size="lg"
                             :selectable="false"
                             @confirm="checkModalConfirm"
        >
            <p-dynamic-layout v-if="tableState.multiSchema"
                              type="simple-table"
                              :options="tableState.multiSchema.options"
                              :data="tableState.selectedItems"
                              :field-handler="fieldHandler"
            />
        </p-table-check-modal>
        <custom-field-modal v-model="tableState.visibleCustomFieldModal"
                            resource-type="inventory.Server"
                            @complete="reloadTable"
        />
    </div>
</template>

<script lang="ts">
import dayjs from 'dayjs';
import { get } from 'lodash';
import { TranslateResult } from 'vue-i18n';

import {
    reactive,
    ComponentRenderProxy, getCurrentInstance, computed, watch,
} from '@vue/composition-api';

import {
    PPageTitle, PHorizontalLayout, PDynamicLayout,
    PTab, PTableCheckModal, PEmpty, PButton,
} from '@spaceone/design-system';
import {
    DynamicLayoutEventListener,
    DynamicLayoutFieldHandler,
} from '@spaceone/design-system/dist/src/data-display/dynamic/dynamic-layout/type';
import { DynamicLayout } from '@spaceone/design-system/dist/src/data-display/dynamic/dynamic-layout/type/layout-schema';

import ServerDetails from '@/services/asset-inventory/server/modules/ServerDetails.vue';
import ServerMember from '@/services/asset-inventory/server/modules/ServerMember.vue';
import ServerHistory from '@/services/asset-inventory/server/modules/ServerHistory.vue';
import Monitoring from '@/common/modules/monitoring/Monitoring.vue';
import TagsPanel from '@/common/modules/tags/tags-panel/TagsPanel.vue';
import { MonitoringProps, MonitoringResourceType } from '@/common/modules/monitoring/type';

import { SpaceConnector } from '@spaceone/console-core-lib/space-connector';
import { ApiQueryHelper } from '@spaceone/console-core-lib/space-connector/helper';
import { replaceUrlQuery } from '@/lib/router-query-string';
import {
    dynamicFieldsToExcelDataFields,
    makeQuerySearchPropsWithSearchSchema,
} from '@/lib/component-util/dynamic-layout';
import { referenceFieldFormatter } from '@/lib/reference/referenceFieldFormatter';
import { showSuccessMessage } from '@/lib/helper/notice-alert-helper';
import { QueryHelper } from '@spaceone/console-core-lib/query';
import { Reference } from '@/lib/reference/type';
import { store } from '@/store';
import { KeyItemSet, ValueHandlerMap } from '@spaceone/design-system/dist/src/inputs/search/query-search/type';
import CustomFieldModal from '@/common/modules/custom-table/custom-field-modal/CustomFieldModal.vue';
import { FILE_NAME_PREFIX } from '@/lib/excel-export';
import ErrorHandler from '@/common/composables/error/errorHandler';
import { QueryStoreFilter } from '@spaceone/console-core-lib/query/type';
import { Period } from '@/services/cost-explorer/type';


interface ProjectItemResp {
    id: string;
    name: string;
    has_child: boolean;
    item_type: 'PROJECT_GROUP' | 'PROJECT';
}

const DEFAULT_PAGE_SIZE = 15;
const STORAGE_PREFIX = 'inventory/server';

export default {
    name: 'ServerMain',
    components: {
        CustomFieldModal,
        PPageTitle,
        ServerDetails,
        ServerMember,
        ServerHistory,
        Monitoring,
        TagsPanel,
        PTableCheckModal,
        PTab,
        PDynamicLayout,
        PHorizontalLayout,
        PEmpty,
        PButton,
    },
    props: {
        isCloudService: {
            type: Boolean,
            default: false,
        },
        provider: {
            type: String,
            default: undefined,
        },
        cloudServiceGroup: {
            type: String,
            default: undefined,
        },
        cloudServiceType: {
            type: String,
            default: undefined,
        },
        disabled: {
            type: Boolean,
            default: false,
        },
        period: {
            type: Object as () => Period | undefined,
            default: undefined,
        },
        minHeight: {
            type: Number,
            default: undefined,
        },
    },
    setup(props, context) {
        const vm = getCurrentInstance() as ComponentRenderProxy;
        const queryHelper = new QueryHelper();
        const apiQuery = new ApiQueryHelper();
        const pageTitle = computed(() => (props.isCloudService ? props.cloudServiceType : vm.$t('INVENTORY.SERVER.MAIN.TITLE')));

        const typeOptionState = reactive({
            loading: true,
            totalCount: 0,
            timezone: computed(() => store.state.user.timezone || 'UTC'),
            selectIndex: [] as number[],
            selectable: true,
            keyItemSets: [] as KeyItemSet[],
            valueHandlerMap: {} as ValueHandlerMap,
            colCopy: false,
            settingsVisible: true,
        });
        const tableHeight = store.getters['settings/getItem']('tableHeight', STORAGE_PREFIX) ?? 0;
        const tableState = reactive({
            schema: null as null | DynamicLayout,
            items: [],
            selectedItems: computed(() => typeOptionState.selectIndex.map(d => tableState.items[d])
                .filter(d => d !== undefined)),
            tableHeight: tableHeight > props.minHeight ? tableHeight : props.minHeight,
            consoleLink: computed(() => get(tableState.selectedItems[0], 'reference.external_link')),
            multiSchema: computed<null | DynamicLayout>(() => {
                if (!tableState.schema) return null;

                const res: DynamicLayout = { ...tableState.schema };
                if (tableState.schema.options.fields) {
                    res.options = {
                        ...tableState.schema.options,
                        fields: [{
                            name: 'Server ID',
                            key: 'server_id',
                        }, ...tableState.schema.options.fields],
                    };
                }

                return res;
            }),
            selectedServerIds: computed(() => tableState.selectedItems.map(d => d.server_id)),
            visibleCustomFieldModal: false,
            // eslint-disable-next-line no-use-before-define
            searchFilters: computed<QueryStoreFilter[]>(() => queryHelper.setFiltersAsQueryTag(fetchOptionState.queryTags).filters),
        });
        const fetchOptionState = reactive({
            pageStart: 1,
            pageLimit: store.getters['settings/getItem']('pageLimit', STORAGE_PREFIX) || DEFAULT_PAGE_SIZE,
            sortDesc: true,
            sortBy: 'created_at',
            queryTags: queryHelper.setFiltersAsRawQueryString(vm.$route.query.filters).queryTags,
        });
        const checkTableModalState = reactive({
            visible: false,
            item: null,
            title: '' as TranslateResult,
            subTitle: '' as TranslateResult,
            themeColor: undefined as string | undefined,
            api: null as any,
            params: null as any,
        });
        // tabs
        const singleItemTabState = reactive({
            tabs: computed(() => [
                {
                    name: 'details',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_DETAILS') as string,
                    type: 'item',
                }, {
                    name: 'tag',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_TAG') as string,
                    type: 'item',
                }, {
                    name: 'member',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_MEMBER') as string,
                    type: 'item',
                }, {
                    name: 'history',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_HISTORY') as string,
                    type: 'item',
                }, {
                    name: 'monitoring',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_MONITORING') as string,
                    type: 'item',
                },
            ]),
            activeTab: 'details',
        });
        const multiItemTabState = reactive({
            tabs: computed(() => [
                {
                    name: 'data',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_SELECTED_DATA') as string,
                    type: 'item',
                }, {
                    name: 'monitoring',
                    label: vm.$t('INVENTORY.SERVER.MAIN.TAB_MONITORING') as string,
                    type: 'item',
                },
            ]),
            activeTab: 'data',
        });
        const monitoringState: MonitoringProps = reactive({
            resourceType: 'inventory.Server',
            resources: computed<MonitoringResourceType[]>(() => tableState.selectedItems.map(d => ({
                id: get(d, 'server_id'),
                name: d.name,
                provider: d.provider,
            }))),
        });

        /* util */
        const fieldHandler: DynamicLayoutFieldHandler<Record<'reference', Reference>> = (field) => {
            if (field.extraData?.reference) {
                return referenceFieldFormatter(field.extraData.reference, field.data);
            }
            return {};
        };

        /* api */
        const getQuery = () => {
            apiQuery.setSort(fetchOptionState.sortBy, fetchOptionState.sortDesc)
                .setPage(fetchOptionState.pageStart, fetchOptionState.pageLimit)
                .setFilters(tableState.searchFilters);

            if (props.isCloudService) {
                apiQuery.addFilter({ k: 'provider', o: '=', v: props.provider },
                    { k: 'cloud_service_type', o: '=', v: props.cloudServiceType },
                    { k: 'cloud_service_group', o: '=', v: props.cloudServiceGroup });
            }
            return apiQuery.data;
        };
        const listServerData = async () => {
            typeOptionState.loading = true;
            try {
                const res = await SpaceConnector.client.inventory.server.list({
                    query: getQuery(),
                    ...(props.period && {
                        date_range: {
                            start: dayjs.utc(props.period.start).format('YYYY-MM-DD'),
                            end: dayjs.utc(props.period.end).add(1, 'day').format('YYYY-MM-DD'),
                        },
                    }),
                });
                tableState.items = res.results;
                typeOptionState.totalCount = res.total_count;
            } catch (e) {
                ErrorHandler.handleError(e);
                tableState.items = [];
                typeOptionState.totalCount = 0;
            } finally {
                typeOptionState.loading = false;
            }
        };
        const exportServerData = async () => {
            await store.dispatch('file/downloadExcel', {
                url: '/inventory/server/list',
                param: { query: getQuery() },
                fields: dynamicFieldsToExcelDataFields(tableState.schema.options.fields),
                file_name_prefix: FILE_NAME_PREFIX.server,
            });
        };
        const getTableSchema = async () => {
            try {
                const res = await SpaceConnector.client.addOns.pageSchema.get({
                    resource_type: 'inventory.Server',
                    schema: 'table',
                });

                // declare keyItemSets and valueHandlerMap with search schema
                if (res?.options?.search) {
                    const searchProps = makeQuerySearchPropsWithSearchSchema(res.options.search, 'inventory.Server');
                    typeOptionState.keyItemSets = searchProps.keyItemSets;
                    typeOptionState.valueHandlerMap = searchProps.valueHandlerMap;
                }
                // set api query to get only a few specified data
                if (res?.options?.fields) {
                    apiQuery.setOnly(...res.options.fields.map(d => d.key).filter(d => !d.startsWith('tags.')),
                        'server_id', 'reference.external_link', 'primary_ip_address', 'collection_info.collectors', 'tags', 'provider');
                }

                // initiate queryTags with keyItemSets
                fetchOptionState.queryTags = queryHelper.setKeyItemSets(typeOptionState.keyItemSets).queryTags;

                // set schema to tableState -> create dynamic layout
                tableState.schema = res;
            } catch (e) {
                ErrorHandler.handleError(e);
            }
        };

        /* event */
        const fetchTableData: DynamicLayoutEventListener['fetch'] = async (changed) => {
            if (changed) {
                if (changed.sortBy !== undefined) {
                    fetchOptionState.sortBy = changed.sortBy;
                    fetchOptionState.sortDesc = !!changed.sortDesc;
                }
                if (changed.pageLimit !== undefined) {
                    fetchOptionState.pageLimit = changed.pageLimit;
                    await store.dispatch('settings/setItem', {
                        key: 'pageLimit',
                        value: changed.pageLimit,
                        path: STORAGE_PREFIX,
                    });
                }
                if (changed.pageStart !== undefined) {
                    fetchOptionState.pageStart = changed.pageStart;
                }
                if (changed.queryTags !== undefined) {
                    fetchOptionState.queryTags = changed.queryTags;
                }
            }

            await listServerData();
        };
        const handleSelect: DynamicLayoutEventListener['select'] = (selectIndex) => {
            typeOptionState.selectIndex = selectIndex;
        };
        const handleClickSettings = () => {
            tableState.visibleCustomFieldModal = true;
        };
        const handleClickConnectToConsole = () => { window.open(tableState.consoleLink, '_blank'); };
        const checkModalConfirm = async () => {
            const resetCheckTableModalState = () => {
                checkTableModalState.visible = false;
                checkTableModalState.title = '';
                checkTableModalState.subTitle = '';
                checkTableModalState.themeColor = undefined;
                checkTableModalState.api = null;
                checkTableModalState.params = null;
            };
            try {
                await checkTableModalState.api({
                    ...checkTableModalState.params,
                    servers: tableState.selectedItems.map(item => item.server_id),
                });
                showSuccessMessage(vm.$t('INVENTORY.SERVER.MAIN.ALT_S_CHECK_MODAL', { action: checkTableModalState.title }), '', context.root);
            } catch (e) {
                ErrorHandler.handleRequestError(e, vm.$t('INVENTORY.SERVER.MAIN.ALT_E_CHECK_MODAL', { action: checkTableModalState.title }));
            } finally {
                typeOptionState.selectIndex = [];
                resetCheckTableModalState();
                await listServerData();
            }
        };
        const handleTableHeightChange = (height) => {
            tableState.tableHeight = height > props.minHeight ? height : props.minHeight;
            store.dispatch('settings/setItem', {
                key: 'tableHeight',
                value: height,
                path: STORAGE_PREFIX,
            });
        };

        const reloadTable = async () => {
            await getTableSchema();
            await listServerData();
        };

        /* init */
        const init = async () => {
            await getTableSchema();
            await listServerData();
        };

        const replaceQueryHelper = new QueryHelper();
        watch(() => tableState.searchFilters, (searchFilters) => {
            replaceQueryHelper.setFilters(searchFilters);
            const filterQueryString = vm.$route.query.filters ?? '';
            if (replaceQueryHelper.rawQueryString !== JSON.stringify(filterQueryString)) {
                replaceUrlQuery('filters', replaceQueryHelper.rawQueryStrings);
            }
        });

        watch(() => props.disabled, (disabled) => {
            if (!disabled) init();
        }, { immediate: true });

        // LOAD REFERENCE STORE
        (async () => {
            await store.dispatch('reference/loadAll');
        })();

        return {
            /* Server Table */
            pageTitle,
            tableState,
            fetchOptionState,
            typeOptionState,
            handleSelect,
            exportServerData,
            handleClickSettings,
            listServerData,
            fetchTableData,
            fieldHandler,
            reloadTable,
            handleTableHeightChange,

            /* Actions & Checking */
            checkTableModalState,
            checkModalConfirm,
            handleClickConnectToConsole,

            /* Tabs */
            singleItemTabState,
            multiItemTabState,
            monitoringState,
        };
    },
};
</script>

<style lang="postcss" scoped>
>>> .p-horizontal-layout .horizontal-contents {
    overflow: unset;
}

.left-toolbox-item {
    margin-left: 1rem;
    &:last-child {
        flex-grow: 1;
    }
}

.empty-space {
    @apply text-primary2 mt-6;
    text-align: center;
    margin-bottom: 0.5rem;
    font-size: 1.5rem;
}

.selected-data-tab {
    @apply mt-8;
}

>>> .p-dynamic-layout-query-search-table .p-toolbox-table {
    @apply border border-gray-200 rounded-lg;
    .p-data-table {
        min-height: unset;
    }
}

.p-tab::v-deep {
    @apply rounded-lg;
    &.monitoring {
        .tab-pane {
            @apply bg-secondary2;
        }
    }
}
</style>
